import AVFoundation
import CoreVideo
import UIKit


public class UIUtilities {

    /**
     Creates a UI Image from file path and resizes it
     - Parameters:
       - filePath: A file URI
       - maxSize: A max width/height
       - isBackground: Passed to resize image to ensure min width/height it used
     - Returns: The UI Image
     */
    public static func loadFileToUiImage(filePath: String, maxSize: NSNumber, isBackground: Bool) -> UIImage? {
        do {
            let url = URL(string: filePath)
            let imageData = try Data(contentsOf: url!)
            let image = UIImage(data: imageData)
            let maximumWidth = CGFloat(maxSize.floatValue);
            let resizedImage = image?.resizeImage(maximumWidth, isBackground: isBackground)
            return resizedImage;
        } catch {
            print("Error loading image : \(error)")
        }
        return nil
    }

    /**
     Crops UI Image to width/height
     - Parameters:
       - image: The UI Image
       - width: The Width to crop to
       - height: The Height to crop to
     - Returns: The UI Image
     */
    public static func cropToBounds(image: UIImage, width: Double, height: Double) -> UIImage {

        let cgimage = image.cgImage!
        let contextImage: UIImage = UIImage(cgImage: cgimage)
        let contextSize: CGSize = contextImage.size
        var posX: CGFloat = 0.0
        var posY: CGFloat = 0.0
        var cgwidth: CGFloat = CGFloat(width)
        var cgheight: CGFloat = CGFloat(height)

        // See what size is longer and create the center off of that
        if contextSize.width > contextSize.height {
           posX = ((contextSize.width - contextSize.height) / 2)
           posY = 0
           cgwidth = contextSize.height
           cgheight = contextSize.height
        } else {
           posX = 0
           posY = ((contextSize.height - contextSize.width) / 2)
           cgwidth = contextSize.width
           cgheight = contextSize.width
        }

        let rect: CGRect = CGRect(x: posX, y: posY, width: cgwidth, height: cgheight)

        // Create bitmap image from context using the rect
        let imageRef: CGImage = cgimage.cropping(to: rect)!

        // Create a new image based on the imageRef and rotate back to the original orientation
        let image: UIImage = UIImage(cgImage: imageRef, scale: image.scale, orientation: image.imageOrientation)

        return image
    }

    /**
     Saves a UI Image to Cache Directory
     - Parameter uiImage: The image
     - Returns: A file path URI
     */
    public static func saveUiImageToFilePath(uiImage: UIImage) -> String? {
        var cacheUrl: URL {
            return FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first!
        }
        let newPhotoFileName = UUID().uuidString + ".jpeg"
        let imagePath = cacheUrl.path + "/" + newPhotoFileName
        let fileSuccess = FileManager.default.createFile(atPath: imagePath, contents: uiImage.jpegData(compressionQuality: 1), attributes: nil)
        return fileSuccess ? imagePath : nil
    }

    /**
     Converts a UI Image to Buffer
     - Parameter image: The image
     - Returns: The buffer
     */
    public static func createImageBuffer(from image: UIImage) -> CVImageBuffer? {
      guard let cgImage = image.cgImage else { return nil }
      let width = cgImage.width
      let height = cgImage.height

      var buffer: CVPixelBuffer? = nil
      CVPixelBufferCreate(
        kCFAllocatorDefault, width, height, kCVPixelFormatType_32BGRA, nil,
        &buffer)
      guard let imageBuffer = buffer else { return nil }

      let flags = CVPixelBufferLockFlags(rawValue: 0)
      CVPixelBufferLockBaseAddress(imageBuffer, flags)
      let baseAddress = CVPixelBufferGetBaseAddress(imageBuffer)
      let colorSpace = CGColorSpaceCreateDeviceRGB()
      let bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer)
      let context = CGContext(
        data: baseAddress, width: width, height: height, bitsPerComponent: 8,
        bytesPerRow: bytesPerRow, space: colorSpace,
        bitmapInfo: (CGImageAlphaInfo.premultipliedFirst.rawValue
          | CGBitmapInfo.byteOrder32Little.rawValue))

      if let context = context {
        let rect = CGRect.init(x: 0, y: 0, width: width, height: height)
        context.draw(cgImage, in: rect)
        CVPixelBufferUnlockBaseAddress(imageBuffer, flags)
        return imageBuffer
      } else {
        CVPixelBufferUnlockBaseAddress(imageBuffer, flags)
        return nil
      }
    }
    
    /**
     Applies the mask to the input image
     - Parameters:
       - mask: The mask generated by Segmenter
       - inputImageBuffer: The input image that the mask and background are applied to
       - backgroundImageBuffer: The background image used to display in the background of the input
     */
    public static func applySegmentationMask(
      mask: SegmentationMask, inputImage inputImageBuffer: CVImageBuffer,
      backgroundImage backgroundImageBuffer: CVImageBuffer
    ) {
      assert(
        CVPixelBufferGetPixelFormatType(inputImageBuffer) == kCVPixelFormatType_32BGRA,
        "Input Image buffer must have 32BGRA pixel format type")

        assert(
          CVPixelBufferGetPixelFormatType(backgroundImageBuffer) == kCVPixelFormatType_32BGRA,
          "Background Image buffer must have 32BGRA pixel format type")
        
      let width = CVPixelBufferGetWidth(mask.buffer)
      let height = CVPixelBufferGetHeight(mask.buffer)
      assert(CVPixelBufferGetWidth(inputImageBuffer) == width, "Width must match")
      assert(CVPixelBufferGetHeight(inputImageBuffer) == height, "Height must match")
        
      assert(CVPixelBufferGetWidth(backgroundImageBuffer) >= CVPixelBufferGetWidth(inputImageBuffer), "Background width must be equal or larger than input")
      assert(CVPixelBufferGetHeight(backgroundImageBuffer) >= CVPixelBufferGetHeight(inputImageBuffer), "Background height must be equal or larger than input")


      let writeFlags = CVPixelBufferLockFlags(rawValue: 0)
      CVPixelBufferLockBaseAddress(inputImageBuffer, writeFlags)
      CVPixelBufferLockBaseAddress(backgroundImageBuffer, writeFlags)
      CVPixelBufferLockBaseAddress(mask.buffer, CVPixelBufferLockFlags.readOnly)

      let maskBytesPerRow = CVPixelBufferGetBytesPerRow(mask.buffer)
      var maskAddress =
        CVPixelBufferGetBaseAddress(mask.buffer)!.bindMemory(
          to: Float32.self, capacity: maskBytesPerRow * height)

      let imageBytesPerRow = CVPixelBufferGetBytesPerRow(inputImageBuffer)
      var imageAddress = CVPixelBufferGetBaseAddress(inputImageBuffer)!.bindMemory(
        to: UInt8.self, capacity: imageBytesPerRow * height)
        
      let backgroundImageBytesPerRow = CVPixelBufferGetBytesPerRow(backgroundImageBuffer)
      var backgroundImageAddress = CVPixelBufferGetBaseAddress(backgroundImageBuffer)!.bindMemory(
          to: UInt8.self, capacity: backgroundImageBytesPerRow * height)
        

      let redFG: CGFloat = 0.0
      let greenFG: CGFloat = 0.0
      let blueFG: CGFloat = 0.0
      let alphaFG: CGFloat = 0.0
      var redBG: CGFloat = 0.0
      var greenBG: CGFloat = 0.0
      var blueBG: CGFloat = 0.0
      var alphaBG: CGFloat = 0.0


      for _ in 0...(height - 1) {
        for col in 0...(width - 1) {
          let pixelOffset = col * Constants.bgraBytesPerPixel
          let blueOffset = pixelOffset
          let greenOffset = pixelOffset + 1
          let redOffset = pixelOffset + 2
          let alphaOffset = pixelOffset + 3

          let maskValue: CGFloat = CGFloat(maskAddress[col])
          let backgroundRegionRatio: CGFloat = 1.0 - maskValue
          let foregroundRegionRatio = maskValue

          let originalPixelRed: CGFloat =
            CGFloat(imageAddress[redOffset]) / Constants.maxColorComponentValue
          let originalPixelGreen: CGFloat =
            CGFloat(imageAddress[greenOffset]) / Constants.maxColorComponentValue
          let originalPixelBlue: CGFloat =
            CGFloat(imageAddress[blueOffset]) / Constants.maxColorComponentValue
          let originalPixelAlpha: CGFloat =
            CGFloat(imageAddress[alphaOffset]) / Constants.maxColorComponentValue
          
          // replace bg colors with those from background image
          redBG = CGFloat(backgroundImageAddress[redOffset]) / Constants.maxColorComponentValue
          greenBG = CGFloat(backgroundImageAddress[greenOffset]) / Constants.maxColorComponentValue
          blueBG = CGFloat(backgroundImageAddress[blueOffset]) / Constants.maxColorComponentValue
          alphaBG = CGFloat(backgroundImageAddress[alphaOffset]) / Constants.maxColorComponentValue
            

          let redOverlay = redBG * backgroundRegionRatio + redFG * foregroundRegionRatio
          let greenOverlay = greenBG * backgroundRegionRatio + greenFG * foregroundRegionRatio
          let blueOverlay = blueBG * backgroundRegionRatio + blueFG * foregroundRegionRatio
          let alphaOverlay = alphaBG * backgroundRegionRatio + alphaFG * foregroundRegionRatio

          // Calculate composite color component values.
          // Derived from https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending
          let compositeAlpha: CGFloat = ((1.0 - alphaOverlay) * originalPixelAlpha) + alphaOverlay
          var compositeRed: CGFloat = 0.0
          var compositeGreen: CGFloat = 0.0
          var compositeBlue: CGFloat = 0.0
          // Only perform rgb blending calculations if the output alpha is > 0. A zero-value alpha
          // means none of the color channels actually matter, and would introduce division by 0.
          if abs(compositeAlpha) > CGFloat(Float.ulpOfOne) {
            compositeRed =
              (((1.0 - alphaOverlay) * originalPixelAlpha * originalPixelRed)
                + (alphaOverlay * redOverlay)) / compositeAlpha
            compositeGreen =
              (((1.0 - alphaOverlay) * originalPixelAlpha * originalPixelGreen)
                + (alphaOverlay * greenOverlay)) / compositeAlpha
            compositeBlue =
              (((1.0 - alphaOverlay) * originalPixelAlpha * originalPixelBlue)
                + (alphaOverlay * blueOverlay)) / compositeAlpha
          }

          imageAddress[redOffset] = UInt8(compositeRed * Constants.maxColorComponentValue)
          imageAddress[greenOffset] = UInt8(compositeGreen * Constants.maxColorComponentValue)
          imageAddress[blueOffset] = UInt8(compositeBlue * Constants.maxColorComponentValue)
        }

        imageAddress += imageBytesPerRow / MemoryLayout<UInt8>.size
        backgroundImageAddress += backgroundImageBytesPerRow / MemoryLayout<UInt8>.size
        maskAddress += maskBytesPerRow / MemoryLayout<Float32>.size
      }

      CVPixelBufferUnlockBaseAddress(inputImageBuffer, writeFlags)
      CVPixelBufferUnlockBaseAddress(backgroundImageBuffer, writeFlags)
      CVPixelBufferUnlockBaseAddress(mask.buffer, CVPixelBufferLockFlags.readOnly)
    }
    
    /**
     Creates a UI Image from Buffer
     - Parameters:
       - imageBuffer: The input buffer
       - orientation: The input orientation
     - Returns: A UI Image
     */
    public static func createUIImage(
      from imageBuffer: CVImageBuffer,
      orientation: UIImage.Orientation
    ) -> UIImage? {
      let ciImage = CIImage(cvPixelBuffer: imageBuffer)
      let context = CIContext(options: nil)
      guard let cgImage = context.createCGImage(ciImage, from: ciImage.extent) else { return nil }
      return UIImage(cgImage: cgImage, scale: Constants.originalScale, orientation: orientation)
    }
    
    /**
     Used for applying the mask to input image
     */
    private enum Constants {
      static let circleViewAlpha: CGFloat = 0.7
      static let rectangleViewAlpha: CGFloat = 0.3
      static let shapeViewAlpha: CGFloat = 0.3
      static let rectangleViewCornerRadius: CGFloat = 10.0
      static let maxColorComponentValue: CGFloat = 255.0
      static let originalScale: CGFloat = 1.0
      static let bgraBytesPerPixel = 4
    }
}

extension UIColor {
    /**
     Converts a hex color string to UI Color
     - Parameter hex: A hex color string like #000000
     */
    public convenience init?(hex: String) {
        let r, g, b, a: CGFloat

        if hex.hasPrefix("#") {
            let start = hex.index(hex.startIndex, offsetBy: 1)
            let hexColor = String(hex[start...])
            
            if hexColor.count == 6 {
                let scanner = Scanner(string: hexColor)
                var hexNumber: UInt64 = 0

                if scanner.scanHexInt64(&hexNumber) {
                    r = CGFloat((hexNumber & 0xFF0000) >> 16) / 255.0
                    g = CGFloat((hexNumber & 0x00FF00) >> 8) / 255.0
                    b = CGFloat(hexNumber & 0x0000FF) / 255.0
                    a = CGFloat(1.0)

                    self.init(red: r, green: g, blue: b, alpha: a)
                    return
                }
            }
        }

        return nil
    }
}

extension UIImage {
    /**
     Resizes a UI Image
     - Parameters:
       - dimension: max height/width
       - isBackground: Determines whether dimension should be the min-width/min-height
     - Returns: A Ui Image
     */
    func resizeImage(_ dimension: CGFloat, isBackground: Bool) -> UIImage {
        var width: CGFloat
        var height: CGFloat
        var newImage: UIImage

        let size = self.size
        // calculate aspect ratio
        let aspectRatio = size.width > size.height ? round((size.width/size.height) * 1000) / 1000 : round((size.height/size.width) * 1000) / 1000
        
        // set default widths/heights
        width = dimension
        height = isBackground ? dimension * aspectRatio : dimension / aspectRatio;
        
        // if the input is portrait, flip the width/height values
        if size.height > size.width && !isBackground {
            width = height
            height = dimension
        }
        
        // if the background is landscape, resize for larger dimension
        if size.width > size.height && isBackground {
            width = dimension * aspectRatio
            height = dimension
        }
        
        if #available(iOS 10.0, *) {
            let renderFormat = UIGraphicsImageRendererFormat.default()
            let renderer = UIGraphicsImageRenderer(size: CGSize(width: width, height: height), format: renderFormat)
            newImage = renderer.image {
                (context) in
                self.draw(in: CGRect(x: 0, y: 0, width: width, height: height))
            }
        } else {
            UIGraphicsBeginImageContextWithOptions(CGSize(width: width, height: height), false, 0)
                self.draw(in: CGRect(x: 0, y: 0, width: width, height: height))
                newImage = UIGraphicsGetImageFromCurrentImageContext()!
            UIGraphicsEndImageContext()
        }

        return newImage
    }
}

